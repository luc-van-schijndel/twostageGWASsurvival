% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/twostagecoxph.R
\name{multicore.twostagecoxph}
\alias{multicore.twostagecoxph}
\title{Multicore method of performing the second stage}
\usage{
multicore.twostagecoxph(
  survival.dataset,
  covariate.matrix,
  first.stage.threshold,
  progress = 50,
  max.coef = 5,
  updatefile = "",
  max.batchsize = 1000,
  upper.bound.correlation = 0.95,
  snps.are.named = FALSE
)
}
\arguments{
\item{survival.dataset}{the outcome data}

\item{covariate.matrix}{The SNPs}

\item{first.stage.threshold}{the FST}

\item{progress}{set to 0 for no updates}

\item{max.coef}{maximum value of fitted weights before declared non-converged}

\item{updatefile}{path to that file}

\item{max.batchsize}{max number of covariates in one batch}

\item{upper.bound.correlation}{upper bound on the correlation before not checked}
}
\value{
list of p-value matrix, first stage p-values and which ones passed.
}
\description{
Multicore method of performing the second stage
}
\details{
Similarly to the multicore method of the first stage, this function works with
batches of covariates to alleviate possible memory issues. The optimal size of the batches
is calculated in a similar fashion as during the first stage, only here we halve the maximum
batchsize, since (almost always) two batches of covariates will be in memory at the same time.

The testing for interactions is done in a first-in, last-out approach. The first batch of
covariates will be tested for interactions with itself, then for with all covariates from
subsequent batches. The second batch does not need to test for interactions with the first one,
since the first one already did that. This allows the second batch to be done before the first one,
hence the "first-in, last-out" naming. The number of batches will always be a multiple of
two times the number of worker cores; this should ensure that all workers should be done
at the same time.

There is quite some code-duplication going on (DRY! OMG! U NUB), but that's for a reason. Function
calls in R have a tiny bit of overhead, and since we would do these function-calls a lot (and I mean a LOT)
of times, I have opted to simply copy the function's code into this function itself, and forego
the function itself.

Since this function is not exported, I will discusse the 6 indices found in the for-loops
(at some point we are 4 for-loops deep)
Firstly, we have the index(es) of the batch(es) that we are currently using. These are quite
selfexplanatory.
Secondly, the "real" indices in the batch. These correspond to the indices of the covariates
within the entire covariate matrix. Therefore, for the very first batch, when these are just
1:batchsize, but they will differ for further batches.
Thirdly, the local index. These are simply the index of the covariates within the batch itself.
These will therefore always start at 1 and not exceed max.batchsize.
Lastly, we also have the vector of passed indices. These correspond to the covariates that
were found to be marginally significant.

Using these indices, we can get all variables we want in all cases, although we sometimes
need to use triple subsets.
}
