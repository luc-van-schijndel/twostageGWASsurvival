% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/batched_twostagecoxph.R
\name{batched.twostagecoxph}
\alias{batched.twostagecoxph}
\title{Performs a large scale two stage analysis on a survival dataset to detect epistasis using batches}
\usage{
batched.twostagecoxph(
  survival.dataset,
  covariate.filepaths,
  first.stage.threshold = 0.05,
  multiple.hypotheses.correction = "bonferroni",
  updatefile = "",
  control = twostagecoxph.control(),
  number.of.covariates = 0,
  read.function = function(x) as.matrix(read.table(x))
)
}
\arguments{
\item{survival.dataset}{The survival dataset describing the outcome.}

\item{covariate.filepaths}{The vector of paths of the files containing the covariates. See Details.}

\item{first.stage.threshold}{Numeric scalar denoting the threshold for the first stage. If a covariate
has a p-value lower than this threshold, it will be passed on to the second stage.}

\item{multiple.hypotheses.correction}{Correction method, a character string. Passed to \code{\link{p.adjust}}}

\item{updatefile}{Path to a text file where updates may be written. Necessary for parallel
computations, since the connection to the terminal will be lost. This
file will in that case serve as a stand-in for the terminal.}

\item{control}{Object of class \code{twostagecoxph.control} specifying various options for performance
of the two stage method.}

\item{number.of.covariates}{The combined total of covariates found in the files specified.
If left unspecified, the function will automatically determine this
value by reading through all files before starting the analysis, thereby
increasing runtimes.}

\item{read.function}{Function used to read batches of covariates from the files specified.
By default, this is \code{function(x) as.matrix(utils::read.table(x))}. Note that
the first argument of the function will be used to pass the filepaths. See Details.}
}
\value{
A twostageGWAS object, which is a list of 7 entries:
  \item{result.list}{A list containing the results and where to find them in either 5 or 7 entries, depending on
  whether or not the covariates are named in the files:
  \describe{
    \item{\code{p.values}}{the non-trivial p-values of the interactions. The list is sorted in ascending
    order by this value. Any p-values that are either NA, 0, or 1 after possibly applying the
    multiple hypotheses correction will not be present in this vector.}
    \item{\code{batch.one}, \code{index.one}, \code{batch.two}, \code{index.two}}{
    the indices describing where to find the two covariates that
    describe the interaction corresponding to the p-values in the previous entry. \code{batch.one}
    and \code{batch.two} give the indices of the files as described in \code{covariate.filepaths}
    containing the two covariates. \code{index.one} and \code{index.two} give the indices of
    the covariates \emph{within} those files, i.e. the local indices.}
    \item{\code{names.one}, \code{names.two}}{if the covariates are named, these are the names
    of the covariates found on the aforementioned indices.}
  }}
  \item{most.significant.results}{A list describing the most significant results found used
  primarily by the print method. The
  number of results reported is specified by the control parameter, default 5. The
  list contains 3 items:
  \describe{
    \item{\code{interacting.snps}}{the names of the interaction, in \code{name_snp_1 x name_snp_2} format.
    In case the covariates in \code{covariate.matrix} have a names attribute, these names are used.
    Otherwise the index of the covariates within the matrix is used.}
    \item{\code{p.value.epistasis}}{the corresponding p-values of the interactions. Unless \code{return.raw = TRUE}
    is specified in the control parameter, these p-values will be corrected for the multiple hypotheses
    tested with the method specified by the \code{multiple.hypotheses.correction} parameter.}
    \item{\code{duplicate.interactions}}{the list of duplicate interactions found, corresponding to
    the interactions specified in this list. An interaction is said to be duplicate if the corresponding
    p-value is the same up until 7 significant figures. }
  }}
  \item{p.value.matrix}{A \code{sparseMatrix} from the package \code{Matrix}, specifying the resulting
  upper triangular p-value matrix obtained from the second stage.  Unless \code{return.raw = TRUE}
    is specified in the control parameter, these p-values will be corrected for the multiple hypotheses
    tested with the method specified by the \code{multiple.hypotheses.correction} parameter. The names
    of the dimensions of the matrix match the ones specified in the files, if the read.function assigns
    dimnames to the matrix. The row and columns corresponding to covariates that were not passed to
    the second stage, have the string \code{as.character(NA)} as names (Note: not NA itself). The entries in these rows and columns are also all absent.}
  \item{marginal.significant}{A vector of named integers, specifying the indices of covariates which
  were found to be marginally significant in the first stage. }
  \item{first.stage}{A vector specifying the p-values found in the first stage. These p-values
  are \emph{not} corrected for the multiple tested hypotheses. }
  \item{fst}{The threshold for significance used in the first stage as specified in \code{first.stage.threshold}}
  \item{runtime}{The total runtime of the function in seconds.}
  \item{call}{The matched call.}
}
\description{
An adaptation of \code{\link{twostagecoxph}} where the covariates will be read from multiple files.
This is to alleviate possible memory constrains. The main functionality assumes a parallel back-end
is registered, e.g. using doParallel::registerDoParallel(2).
}
\details{
At all times on all registered cores, the contents of at most 2 files will be in memory.
           Take note however, that the results will be written to a matrix of substantial size
           (\code{covariates_per_file x total_number_of_covariates}) so it is best if enough memory
           is still available after reading the files. \cr \cr
           The function assumes that the object returned by \code{read.function} is a matrix containing
           the covariates with one column per covariate and one row per subject This assumption
           will only be checked once at function start. If the files are not structured the
           same, the results may be unreliable or an error may be thrown. If the \code{read.function}
           assignes dimnames to the columns, these names will be kept and passed on to the resulting
           object. If not, the indices of the covariates (counting across all files) will be used as
           the names. \cr \cr
           The function assumes the files have same number of covariates, except for the last one,
           which may have less. \code{number.of.covariates}
           will be divided by the amount of covariates per file, and the remainder of that division
           \emph{must} be the number of covariates in the last file.
}
\note{
Parallel processing requires a properly registered parallel back-end, such as one obtained
        from \code{doParallel::registerDoParallel(2)} to be used by \code{foreach} and the  binary operator. \cr \cr
        Be aware that any progress updates are only rough estimates of the current progress and remaining runtime.
        Since the parallel processes are not inter-connected, the estimates are based on the
        progress itself and therefore highly unreliable if the fraction of processes to workers is
        relatively low.
}
\examples{
str(example_survival_data)
str(example_snp_data)

#We shrink the example to run faster, try altering this! :)
example_snp_data <- example_snp_data[,1:100]

#Split the covariate matrix into various files.
number.of.covs <- dim(example_snp_data)[2]
number.of.files <- 6
#500 is not a multiple of 500, so the last file has less covariates than the other ones
temp.snpfile.paths <- tempfile(rep("snpfile", number.of.files),
                               tmpdir = tempdir(check = TRUE),
                               fileext = ".txt")
indices.matrix <-
  matrix(c(seq_len(number.of.covs),
           rep(NA, ceiling(number.of.covs/number.of.files)*number.of.files - number.of.covs)),
         ncol = number.of.files)
for(file.num in 1:number.of.files){
  indices <- indices.matrix[,file.num]
  write.table(example_snp_data[,indices[!is.na(indices)]], file = temp.snpfile.paths[file.num])
}

#make a file to get updates on the progress of the function
updatefile <- tempfile("updatefile", fileext = ".txt")
file(updatefile)

foo <- batched.twostagecoxph(example_survival_data, temp.snpfile.paths,
                             number.of.covariates = number.of.covs,
                             first.stage.threshold = 1e-2,
                             updatefile = updatefile)
readLines(updatefile)
print(foo)
}
\seealso{
\code{\link{foreach}}, \code{\link{print.twostageGWAS}}, \code{\link{twostagecoxph.control}}
}
