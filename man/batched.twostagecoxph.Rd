% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/batched_twostagecoxph.R
\name{batched.twostagecoxph}
\alias{batched.twostagecoxph}
\title{Performs a large scale two stage analysis on a survival dataset to detect epistasis using batches}
\usage{
batched.twostagecoxph(
  survival.dataset,
  covariate.filepaths,
  first.stage.threshold = 0.05,
  multiple.hypotheses.correction = "bonferroni",
  updatefile = "",
  control = twostagecoxph.control(),
  number.of.covariates = 0,
  read.function = function(x) as.matrix(read.table(x))
)
}
\arguments{
\item{survival.dataset}{The survival dataset describing the outcome.}

\item{covariate.filepaths}{The vector of paths of the files containing the covariates. See Details.}

\item{first.stage.threshold}{Numeric scalar denoting the threshold for the first stage. If a covariate
has a p-value lower than this threshold, it will be passed on to the second stage.}

\item{multiple.hypotheses.correction}{Correction method, a character string. Passed to \code{\link{p.adjust}}}

\item{updatefile}{Path to a text file where updates may be written. Necessary for parallel
computations, since the connection to the terminal will be lost. This
file will in that case serve as a stand-in for the terminal.}

\item{control}{Object of class \code{twostagecoxph.control} specifying various options for performance
of the two stage method.}

\item{number.of.covariates}{The combined total of covariates found in the files specified.
If left unspecified, the function will automatically determine this
value by reading through all files before starting the analysis, thereby
increasing runtimes.}

\item{read.function}{Function used to read batches of covariates from the files specified.
By default, this is \code{function(x) as.matrix(utils::read.table(x))}. Note that
the first argument of the function will be used to pass the filepaths. See Details.}
}
\value{
A twostageGWAS object, which is a list of 7 entries:
\item{result.list}{A list containing the results and where to find them in either 5 or 7 entries, depending on
whether or not the covariates are named in the files:
\describe{
\item{\code{p.values}}{the non-trivial p-values of the interactions. The list is sorted in ascending
order by this value. Any p-values that are either NA, 0, or 1 after possibly applying the
multiple hypotheses correction will not be present in this vector.}
\item{\code{batch.one}, \code{index.one}, \code{batch.two}, \code{index.two}}{
the indices describing where to find the two covariates that
describe the interaction corresponding to the p-values in the previous entry. \code{batch.one}
and \code{batch.two} give the indices of the files as described in \code{covariate.filepaths}
containing the two covariates. \code{index.one} and \code{index.two} give the indices of
the covariates \emph{within} those files, i.e. the local indices.}
\item{\code{names.one}, \code{names.two}}{if the covariates are named, these are the names
of the covariates found on the aforementioned indices.}
}}
\item{most.significant.results}{A list describing the most significant results found used
primarily by the print method. The
number of results reported is specified by the control parameter, default 5. The
list contains 3 items:
\describe{
\item{\code{interacting.snps}}{the names of the interaction, in "name_snp_1 x name_snp_2" format.
In case the covariates in \code{covariate.matrix} have a names attribute, these names are used.
Otherwise the index of the covariates within the matrix is used.}
\item{\code{p.value.epistasis}}{the corresponding p-values of the interactions. Unless \code{return.raw = TRUE}
is specified in the control parameter, these p-values will be corrected for the multiple hypotheses
tested with the method specified by the \code{multiple.hypotheses.correction} parameter.}
\item{\code{duplicate.interactions}}{the list of duplicate interactions found, corresponding to
the interactions specified in this list. An interaction is said to be duplicate if the corresponding
p-value is the same up until 7 significant figures. }
}}
\item{p.value.matrix}{A \code{sparseMatrix} from the package "Matrix", specifying the resulting
upper triangular p-value matrix obtained from the second stage.  Unless \code{return.raw = TRUE}
is specified in the control parameter, these p-values will be corrected for the multiple hypotheses
tested with the method specified by the \code{multiple.hypotheses.correction} parameter. The names
of the dimensions of the matrix match the ones specified in the files, if the read.function assigns
dimnames to the matrix. The row and columns corresponding to covariates that were not passed to
the second stage, have names '"NA"' (Note: not 'NA'). The entries in these rows and columns are also all absent.}
\item{marginal.significant}{A vector of named integers, specifying the indices of covariates which
were found to be marginally significant in the first stage. }
\item{first.stage}{A vector specifying the p-values found in the first stage. These p-values
are \emph{not} corrected for the multiple tested hypotheses. }
\item{fst}{The threshold for significance used in the first stage as specified in \code{first.stage.threshold}}
\item{runtime}{The total runtime of the function in seconds.}
\item{call}{The matched call.}
}
\description{
An adaptation of \code{\link{twostagecoxph}} where the covariates will be read from multiple files.
This is to alleviate possible memory constrains. The main functionality assumes a parallel back-end
is registered, e.g. using doParallel::registerDoParallel(2).
}
\details{
At all times on all registered cores, the contents of at most 2 files will be in memory.
Take note however, that the results will be written to a matrix of substantial size
(\code{covariates_per_file x total_number_of_covariates}) so it is best if enough memory
is still available after reading the files. \cr \cr
The function assumes that the object returned by \code{read.function} is a matrix containing
the covariates with one column per covariate and one row per subject This assumption
will only be checked once at function start. If the files are not structured the
same, the results may be unreliable or an error may be thrown. If the \code{read.function}
assignes dimnames to the columns, these names will be kept and passed on to the resulting
object. If not, the indices of the covariates (counting across all files) will be used as
the names. \cr \cr
The function assumes the files have same number of covariates, except for the last one,
which may have less. \code{number.of.covariates}
will be divided by the amount of covariates per file, and the remainder of that division
\emph{must} be the number of covariates in the last file.
}
\note{
Parallel processing requires a properly registered parallel back-end, such as one obtained
from "doParallel::registerDoParallel(2)" to be used by \code{foreach} and the \code{\%dopar\%} binary operator. \cr \cr
Be aware that any progress updates are only rough estimates of the current progress and remaining runtime.
Since the parallel processes are not inter-connected, the estimates are based on the
progress itself and therefore very unreliable if the fraction of processes to workers is
low.
}
\examples{
str(example_survival_data)
str(example_snp_data)

#Split the covariate matrix into various files.
number.of.covs <- dim(example_snp_data)[2]
number.of.files <- 6
#500 is not a multiple of 500, so the last file has less covariates than the other ones
temp.snpfile.paths <- tempfile(rep("snpfile", number.of.files),
                               tmpdir = tempdir(check = TRUE),
                               fileext = ".txt")
indices.matrix <-
  matrix(c(seq_len(number.of.covs),
           rep(NA, ceiling(number.of.covs/number.of.files)*number.of.files - number.of.covs)),
         ncol = number.of.files)
for(file.num in 1:number.of.files){
  indices <- indices.matrix[,file.num]
  write.table(example_snp_data[,indices[!is.na(indices)]], file = temp.snpfile.paths[file.num])
}

#make a file to get updates on the progress of the function
updatefile <- tempfile("updatefile", fileext = ".txt")
file(updatefile)

foo <- batched.twostagecoxph(example_survival_data, temp.snpfile.paths,
                             number.of.covariates = number.of.covs,
                             first.stage.threshold = 1e-2,
                             updatefile = updatefile)
readLines(updatefile)
print(foo)
}
\seealso{
\code{\link{foreach}}, \code{\link{print.twostageGWAS}}, \code{\link{twostagecoxph.control}}
}
